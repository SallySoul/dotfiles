#!/usr/bin/env perl
use strict;
use warnings;


BEGIN {
    our $BNI = ( getpwnam('bni') )[7];
    do "$BNI/plib/InitBNI.pm" or die $@;
}

use BNI::Radar;
use Cortex;
use Getopt::Long;
use Params::Validate qw(:all);

sub usage {
    print "ERROR: $_[0]\n\n" if $_[0];

    my $message = "
A tool to verify owner and radar component information from cortex

Mandatory Flags:
    -train <train>              The train to query

Options:
    -help                       Brings up the usage menu
";   

    print $message;
    
    exit 1; 
}

sub parseArgs {
    my %args;
    
    usage()
        unless GetOptions(
            \%args, 'train=s', 'help'
        );

    # Validate input
    usage if $args{help};
    usage("You must pass -train <train>") if ! $args{train};

    return %args;    
}

sub establishKerberosCredentials {
    my $krb;

    # If were NOT outputting to a tty, and we are root then get LRE credentials
    if ( !-t STDIN && !-t STDOUT && $> == 0 ) {
        $krb = BNI::Auth::getLRECredentials();
    }
    # Otherwise, we need to establish credentials? TODO learn what you are saying
    else {
        my $status;
        ( $status, undef, $krb )
            = CBL::Kerberos::KrbConnect->establishCredsForLREService( preferRealUser => 1 );
        if ($status) {
            die(      'Establishing Kerberos credentials failed. Try running '
                    . '`kdestroy -A` and then calling this tool again.' );
        }
        my $message = 'Credentials established for: ' . $krb->krbUser() . '@' . $krb->realm();
        print "$message\n";
        # TODO fix this print mess
    }

    return $krb;
}

sub validate_component {
    my %options = validate (
        @_,
        {   component   => { type => SCALAR,    optional => 0 },
            radar       => { type => HASHREF,   optional => 0 }
        }
    );

    if ($options{component} =~ /(.*) | (.*)/) {
        my $component = $1;
        my $version = $2;

        my @results = $options{radar}->componentsForComponentAndVersionFragments(
            component => $component,
            version => $version
        );

        foreach my $result (@results) {
            my $c = $result->{name};
            my $v = $result->{version};
            if ($options{component} == "$c | $v") {
                return 1;
            }
        }

        print "\t\tDid not find $options{component}, did find:\n";
        map { print "\t\t\t$_->{name} | $_->{version}\n" } @results;
        return 0;
    } else {
        return 0;
    }
}

sub validate_email {
    my %options = validate (
        @_,
        {   email   => { type => SCALAR,    optional => 0 },
            ldap    => { type => HASHREF,   optional => 0 }, 
        }
    );
    
    my $result = $options{ldap}->search(
        base    => "o=apple computer",
        filter  => "(mail=$options{email})" 
    );
    
    my $n = scalar $result->entries;

    return $n > 0;
}

sub main {
    my %args = parseArgs();
    
    # We will need a radar handle to query the components
    my $krb = establishKerberosCredentials();
    my $krb_user = $krb->krbUser();
    my $radar_handle = BNI::Radar->new( user => $krb_user );
    
    # We will need the an LDAP handle to query the email addresses
    my $ldap = Net::LDAP->new('ldap.apple.com');
    $ldap->bind();

    my $cortex = Cortex->new();
    my @cortex_results = $cortex->listProjectAttributes(
        train => $args{train},
        returnFields => [ 'primaryOwner', 'secondaryOwners', 'project', 'radarComponents' ]
    );
    
    my $problem_count = 0;
    foreach my $result (@cortex_results) {
        my $name = $result->project();
        my $report = "";

        if ($name =~ /_Loc_/) {
            next;
        } else {
            $report .= "Auditing $name:\n";
        }
        
        # Assume this project passes, until it fails 
        my $check = 1;

        my $primary_owner = $result->primaryOwner();
        if ($primary_owner) {
            $report .= "\tPrimary Owner:\n";
            
            if ($primary_owner !~ /apple\.com/) {
                $report .= "\t\t Found $primary_owner, fixing...\n";
                $primary_owner .= '@apple.com';                
            }

            my $primary_check = validate_email(
                email => $primary_owner,
                ldap => $ldap
            );

            my $check = $check && $primary_check;

            $report .= "\t\t$primary_owner: $primary_check\n";
        } 
        # Not having a primary owner is a failure 
        else {
           $check = 0;
           $report .= "\tNo primary Owner found\n"; 
        }

        my @secondary_owners = @{$result->secondaryOwners()};
        $report .= "\tSecondary Owners:\n";
        foreach my $email (@secondary_owners) {
            if (! $email) {
                $check = 0;
                print "\t\tInvalid email?\n";
                next;
           }

            if ($email !~ /apple\.com/) {
                $report .= "\t\t Found $email, fixing...\n";
                $email .= '@apple.com';                
            }

            my $email_check = validate_email(
                email => $email,
                ldap => $ldap
            );

            $report .= "\t\t$email: $email_check\n";

            $check = $check && $email_check;
        }

#        my @radar_components = @{$result->radarComponents()};
#        if (scalar @radar_components == 0) {
#            print "\tNo Radar components found!\n";
#            $check = 0;
#        } else {
#            print "\tRadar Components:\n";
#            foreach my $r (@radar_components) {
#                my $radar_check = validate_component(
#                    component => $r,
#                    radar => $radar_handle,
#                );
#                my $check = $check && $radar_check;
#                print "\t\t$r: $radar_check\n";
#            }
#        }
#        
        if ( ! $check ) {
            print $report if ! $check;
            $problem_count += 1;
        }

    }

    print "Found $problem_count issues\n"
}

main();
