#!/usr/bin/env perl

use strict;
use warnings;
use Getopt::Long;
use File::Glob;

sub usage {
    my $program = "uploadInspector";

    die <<"EOF"
PURPOSE:
    uploadInspector reads the BEAT log for finalNFAuploads and reports information about uploads. 
    You can also pass a log file if you have moved uploads somewhere else. 
    The completed table needs some work.
USAGE:
    $program [OPTIONS]
    
OPTIONAL PARAMETERS:
    -h / --help     Display the usage message
    -runningTable   Display table of currently running uploads
    -completedTable Display table of completed uploads
    -unknownTable   Display table of entries with unknown status
    -printLogPath   Display the path of the BEAR log to be parsed
    -log <log file> Parse the given log file, instead of latest log file. 
    -all            Display all the tables
EOF
}

my %imagesUploading;
my %imagesPID;
my %imagesSuccess;
my %pidSuccess;
my $runningTableFlag;
my $completedTableFlag;
my $unknownTableFlag;
my $printLogPathFlag;
my $helpFlag;
my $allFlag;
my $logFile;

sub parseArgs {
    GetOptions(
        'runningTable|?'    => \$runningTableFlag,
        'completedTable|?'  => \$completedTableFlag,
        'unknownTable|?'    => \$unknownTableFlag,
        'printLogPath|?'    => \$printLogPathFlag,
        'help|?'            => \$helpFlag,
        'allFlag|?'         => \$allFlag,
        'log=s'             => \$logFile,
    ) or usage();

    if ($helpFlag) {
        usage();
    }

    if ($allFlag) {
        $runningTableFlag = "true";
        $completedTableFlag = "true";
        $unknownTableFlag = "true";
    }
}

sub getLogFile {
    my ($beatLogs, $uploadDir);
    opendir($beatLogs, "/Logs/BEAT/") || die "Cannot open /Logs/BEAT/\n";

    # Sort by date modified, we want the most recent 
    my @beatDirs = sort {(stat "/Logs/BEAT/$b")[10] cmp (stat "/Logs/BEAT/$a")[10]} (readdir $beatLogs);
    my $finalUploadsReg = qr{_finalUploads.buildconfig_root};
    while (my $beatDir = shift @beatDirs) {
        if ( $beatDir =~ /$finalUploadsReg/) {
            $uploadDir = $beatDir;
            last;
        }
    }
    close ($beatLogs);

    if (!$uploadDir) {
        die "Could not find a finalUploads BEAT log...\n";
    }

    my @logs = <"/Logs/BEAT/$uploadDir/finalNFAuploads*">;
    my $log = $logs[0];
    if (!$log) {
        die "Could not find finalNFAuploads log in $uploadDir...\n";
    }
    
    return $log;
}

sub readInfo {
    my $debugNext = 0;
    my $lastImage;

    open my $info, $logFile or die "Could not open $logFile: $!";
    while( my $line = <$info>)  {   
        if ($debugNext && $line =~ /DEBUG: Child process is ([0-9]*)\.(.*)/) {
            $imagesPID{$lastImage} = $1;
            $debugNext = 0;
        }
        elsif ($line =~ /Uploading ([a-zA-Z0-9_]*) for (.*)\n/) {
            $imagesUploading{$1} = 1;
            $lastImage = $1;
            $debugNext = 1;
        }
        elsif ($line =~ /\** ([a-zA-Z0-9_]*) - (.*) - SUCCESS \**\n/) {
            $imagesSuccess{$1} = 1;
        }
        elsif ($line =~ /DEBUG: Child process with PID ([0-9]*) has finished\./) {
            $pidSuccess{$1} = 1; 
        }
    }
    close $info;
}

sub printRunningTable {
    print "RUNNING\n";
    print "PID\tDur.\tImage name\n";
    foreach my $image (sort (keys %imagesUploading)) {
        if (!exists $imagesSuccess{$image}) {
            if (!exists $imagesPID{$image}) {
                next;
            }
            my $pid = $imagesPID{$image}; 
            if (exists $pidSuccess{$pid}) {
                next;
            }
            my $length = `ps -p $imagesPID{$image} -o etime=`;
            chomp $length;
            print "$pid\t$length\t$image\n";
        }
    }
}

sub printCompletedTable {
    print "COMPLETED\n";
    print "PID\tPID Succ.\tImage name\n";
    foreach my $image (sort (keys %imagesSuccess)) {
        if (!exists $imagesPID{$image}) {
            next;
        }
        my $pid = $imagesPID{$image};
        print "$pid\t$pidSuccess{$pid}\t$image\n";
    }
}

# at the moment, the only unknown info would be PID
sub printUnknownTable {
    print "UKNOWN INFO\n";
    print "PID\tSuc\tPID Suc\tImage name\n";
    foreach my $image (sort (keys %imagesUploading)) {
        my $pid = exists $imagesPID{$image} ? $imagesPID{$image} : "  ?  ";
        my $finishedFlag = exists $imagesSuccess{$image} ? "Yes" : "?";
        my $pidFlag = exists $pidSuccess{$pid} ? "Yes" : "?";
        print "$pid\t$finishedFlag\t$pidFlag\t$image\n";
    }    
}

sub main {
    parseArgs();
    if (!$logFile) {
        $logFile = getLogFile();
    }
    if ($printLogPathFlag) {
        print "log: $logFile\n";
    }

    readInfo();

    if ($runningTableFlag) {
        printRunningTable();
        print "\n\n";
    }
    if ($completedTableFlag) {
        printCompletedTable();    
        print "\n\n";
    }
    if ($unknownTableFlag) {
        printUnknownTable();
        print "\n\n";
    }
}

main();
